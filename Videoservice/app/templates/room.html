<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Room: {{ room_name }}</title>
    <style>
        #videos {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        video {
            width: 300px;
            height: auto;
            border: 2px solid black;
            border-radius: 5px;
        }
        #chatBox {
            border: 1px solid black;
            height: 200px;
            overflow-y: auto;
            padding: 10px;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <h1>Room: {{ room_name }}</h1>
    <div id="videos">
        <video id="localVideo" autoplay playsinline muted></video>
    </div>
    <input type="text" id="chatInput" placeholder="Type a message and press Enter">
    <button id="call_end">End Call</button>
    <button id="mute">Mute</button>
    <button id="video_mute">Turn off</button>
    <button id="share_screen">Share Screen</button>
    <div id="chatBox"></div>

    <script>
        const roomName = "{{ room_name }}";
        const userId = "ritz";
        // const signalingServer = `ws://localhost:8000/ws/${roomName}/${userId}`;
        const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const signalingServer = `${wsProtocol}//${window.location.host}/ws/${roomName}/${userId}`;
        var muteBttn = document.getElementById("mute");
        var muteVidBttn = document.getElementById("video_mute");
        var callEndBttn = document.getElementById("call_end");
        var shareScreenBttn = document.getElementById("share_screen");
        let ws;
        let localStream;
        let peerConnections = {};
        const existingUsers = new Set();
        var audioMuted = false;
        var videoMuted = false;
        var shareScreen = false;
        var myVideo = document.getElementById("localVideo");
        const configuration = {
            iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
        };

        shareScreenBttn.addEventListener("click", async () => {
            if (shareScreen) {
                stopScreenSharing();
            } else {
                await startScreenSharing();
            }
        });

        async function startScreenSharing() {
            try {
                screenStream = await navigator.mediaDevices.getDisplayMedia({ video: true });
                const screenTrack = screenStream.getVideoTracks()[0];
                Object.values(peerConnections).forEach(pc => {
                    const sender = pc.getSenders().find(s => s.track.kind === "video");
                    if (sender) {
                        sender.replaceTrack(screenTrack);
                    }
                });
                myVideo.srcObject = screenStream;
                screenTrack.onended = stopScreenSharing;
                shareScreen = true;
                shareScreenBttn.innerText = "Stop Sharing";
            } catch (error) {
                console.error("Error sharing screen:", error);
            }
        }

        function stopScreenSharing() {
            if (screenStream) {
                screenStream.getTracks().forEach(track => track.stop());
            }
            const videoTrack = localStream.getVideoTracks()[0];
            Object.values(peerConnections).forEach(pc => {
                const sender = pc.getSenders().find(s => s.track.kind === "video");
                if (sender) {
                    sender.replaceTrack(videoTrack);
                }
            });

            myVideo.srcObject = localStream;
            shareScreen = false;
            shareScreenBttn.innerText = "Share Screen";
        }


        muteBttn.addEventListener("click", (event)=>{
        audioMuted = !audioMuted;
        setAudioMuteState(audioMuted);        
        });    
        muteVidBttn.addEventListener("click", (event)=>{
            videoMuted = !videoMuted;
            setVideoMuteState(videoMuted);        
        });    


        // Clean up function to handle page refresh/close
        window.onbeforeunload = () => {
            // Close all peer connections
            Object.values(peerConnections).forEach(pc => pc.close());
            // Close WebSocket connection
            if (ws) ws.close();
            // Stop all tracks in local stream
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
            }
        };

        function setAudioMuteState(flag)
        {
            let local_stream = myVideo.srcObject;
            local_stream.getAudioTracks().forEach((track)=>{track.enabled = !flag;});
            muteBttn.innerText = flag ? "Unmute" : "Mute";
        }
        function setVideoMuteState(flag)
        {
            let local_stream = myVideo.srcObject;
            local_stream.getVideoTracks().forEach((track)=>{track.enabled = !flag;});
            muteVidBttn.innerText = flag ? "Turn on" : "Turn off";
        }

        // function connectWebSocket() {
        //     ws = new WebSocket(signalingServer);

        //     ws.onopen = () => {
        //         console.log("Connected to signaling server");
        //         startCall();
        //     };

        //     ws.onclose = () => {
        //         console.log("WebSocket connection closed. Attempting to reconnect...");
        //         setTimeout(connectWebSocket, 3000);
        //     };

        //     ws.onerror = (error) => {
        //         console.error("WebSocket error:", error);
        //     };
        // }

        //redis related
        let reconnectAttempts = 0;
        const maxReconnectAttempts = 5;
        const baseReconnectDelay = 1000;

        function connectWebSocket() {
            ws = new WebSocket(signalingServer);

            ws.onopen = () => {
                console.log("Connected to signaling server");
                reconnectAttempts = 0;
                startCall();
            };

            ws.onclose = () => {
                console.log("WebSocket connection closed.");
                if (reconnectAttempts < maxReconnectAttempts) {
                    const delay = Math.min(1000 * Math.pow(2, reconnectAttempts), 30000);
                    console.log(`Attempting to reconnect in ${delay/1000} seconds...`);
                    setTimeout(connectWebSocket, delay);
                    reconnectAttempts++;
                } else {
                    console.log("Maximum reconnection attempts reached.");
                    alert("Connection lost. Please refresh the page to try again.");
                }
            };

            ws.onerror = (error) => {
                console.error("WebSocket error:", error);
            };
        }

        function displayMessage(from, message, timestamp = null) {
            const chatBox = document.getElementById("chatBox");
            const timeStr = timestamp ? `[${timestamp}] ` : '';
            chatBox.innerHTML += `<p>${timeStr}${from}: ${message}</p>`;
            chatBox.scrollTop = chatBox.scrollHeight;
        }

        callEndBttn.addEventListener("click", (event) => {
        ws.send(JSON.stringify({ type: "user-disconnected", from: userId }));
        Object.keys(peerConnections).forEach(remoteUserId => {
            if (peerConnections[remoteUserId]) {
                peerConnections[remoteUserId].close();
                delete peerConnections[remoteUserId];
            }
        });
        existingUsers.clear();
        if (ws) ws.close();
        if (localStream) {
            localStream.getTracks().forEach(track => track.stop());
        }
        window.location.replace("/");
    });


        async function startCall() {
            try {
                if (!localStream) {
                    localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: true });
                    const localVideo = document.getElementById("localVideo");
                    localVideo.srcObject = localStream;
                }

                ws.onmessage = async (message) => {
                    const data = JSON.parse(message.data);
                    const { type, from, to, offer, answer, candidate, message: chatMessage, messages, timestamp } = data;

                    // Ignore messages from self
                    if (from === userId) return;

                    switch (type) {
                        case "offer":
                            if (!peerConnections[from]) {
                                const pc = await createPeerConnection(from);
                                await pc.setRemoteDescription(new RTCSessionDescription(offer));
                                const answer = await pc.createAnswer();
                                await pc.setLocalDescription(answer);
                                ws.send(JSON.stringify({ type: "answer", from: userId, to: from, answer }));
                            }
                            break;

                        case "answer":
                            if (peerConnections[from]) {
                                await peerConnections[from].setRemoteDescription(new RTCSessionDescription(answer));
                            }
                            break;

                        case "ice-candidate":
                            if (peerConnections[from]) {
                                await peerConnections[from].addIceCandidate(new RTCIceCandidate(candidate));
                            }
                            break;

                        case "chat-message":
                            displayMessage(from, chatMessage, timestamp);
                            break;

                        case "new-user":
                            if (!peerConnections[from]) {
                                const pc = await createPeerConnection(from);
                                const offer = await pc.createOffer();
                                await pc.setLocalDescription(offer);
                                ws.send(JSON.stringify({ type: "offer", from: userId, to: from, offer }));
                            }
                            break;
                        
                        case "chat-history":
                            document.getElementById("chatBox").innerHTML = "";
                            console.log(messages);
                                // Display all messages from history
                                messages.forEach(msg => {
                                    displayMessage(msg.from, msg.message, msg.timestamp);
                                });
                                break;

                        case "user-disconnected":
                            removeVideo(`remote-${from}`);
                            if (peerConnections[from]) {
                                peerConnections[from].close();
                                delete peerConnections[from];
                            }
                            existingUsers.delete(from);
                            break;
                    }
                };

                // Notify others of your presence
                ws.send(JSON.stringify({ type: "new-user", from: userId }));
            } catch (error) {
                console.error("Error in startCall:", error);
            }
        }



        async function createPeerConnection(remoteUserId) {
            const pc = new RTCPeerConnection(configuration);
            peerConnections[remoteUserId] = pc;

            pc.onicecandidate = (event) => {
                if (event.candidate) {
                    ws.send(JSON.stringify({
                        type: "ice-candidate",
                        from: userId,
                        to: remoteUserId,
                        candidate: event.candidate
                    }));
                }
            };

            pc.ontrack = (event) => {
                if (!existingUsers.has(remoteUserId)) {
                    addVideoStream(event.streams[0], `remote-${remoteUserId}`);
                    existingUsers.add(remoteUserId);
                }
            };

            // Add local tracks to the connection
            localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
            
            return pc;
        }

        function addVideoStream(stream, id) {
            removeVideo(id); // Remove any existing video element with the same ID
            const videoElement = document.createElement("video");
            videoElement.id = id;
            videoElement.autoplay = true;
            videoElement.playsinline = true;
            videoElement.srcObject = stream;
            document.getElementById("videos").appendChild(videoElement);
        }

        function removeVideo(id) {
            const videoElement = document.getElementById(id);
            if (videoElement) {
                videoElement.srcObject = null;
                videoElement.remove();
            }
        }
        document.getElementById("chatInput").addEventListener("keydown", (event) => {
            if (event.key === "Enter") {
                const chatMessage = event.target.value.trim();
                if (chatMessage) {
                    const messageData = {
                        type: "chat-message",
                        from: userId,
                        message: chatMessage,
                        timestamp: new Date().toLocaleTimeString()
                    };
                    // Display message immediately
                    displayMessage(userId, chatMessage, messageData.timestamp);
                    // Send to others
                    ws.send(JSON.stringify(messageData));
                    event.target.value = "";
                }
            }
        });

        // Start the WebSocket connection
        connectWebSocket();
    </script>
</body>
</html>